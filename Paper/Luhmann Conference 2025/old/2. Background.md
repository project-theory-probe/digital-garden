### **2. Background: Systems Theory and the Question of Mediation**

  

**Purpose:** Clarify your theoretical foundation and what you’re building on or departing from.

**Content:**

- Recap of Niklas Luhmann’s theory of autopoietic communication systems.
    
    - Code and programme distinction.
        
    - Role of media in enabling communication (optional: cite _Theory of Society_, _Social Systems_).
        
    
- Why “functionally differentiated” is not the lens here.
    
- Positioning: You focus not on institutional stabilization, but on _operational closure and medium-specific reproduction_.


## **2. Theoretical Background: Communication, Code, and Closure**

Niklas Luhmann’s social systems theory redefined the basic unit of the social from actions or subjects to **communication**. In his framework, society is not composed of individuals interacting, but of recursively linked communications that constitute autopoietic systems. These systems reproduce themselves by referencing only prior communications of the same system. This move toward operational closure—where each system observes and reproduces itself using its own code and programme—allows Luhmann to describe society as a differentiated whole, composed of subsystems like law, politics, economy, and science, each with their own guiding binary code.

For Luhmann, **code** is a “symbolically generalized medium of communication,” enabling a system to distinguish what counts as valid or invalid communication within its domain. For example, the legal system is guided by the binary code legal/illegal, the economic system by payment/non-payment, and science by true/false. Each system uses these codes to simplify complexity and make decisions under uncertainty. Codes are sustained by **programmes**—structures that provide criteria for applying the code in varying contexts.

However, Luhmann’s canonical examples primarily focus on institutionalized systems with highly formalized criteria for decision-making. What remains under-theorized is how systems might emerge not from institutions, but from practices—particularly those grounded in material production. This gap becomes relevant when examining hacking and software development, where communication often does not hinge on symbolic validation or consensus, but on **executability**. In such domains, the distinction between valid and invalid communication is determined not by a vote or argument but by whether something compiles, runs, or breaks.

### **2.1 Communication in Code-Centric Systems**

Traditional theories of communication—whether linguistic, behavioral, or semiotic—focus on messages transmitted between agents. Luhmann departs from this by asserting that **communication is a synthesis of three selections**: information, utterance, and understanding. These selections must be coordinated for communication to occur. In software development, these elements are often embedded in **source code**, which functions simultaneously as message (utterance), instruction (information), and testable artifact (understanding).

What makes hacking distinct as a communicative formation is that these selections are **reproducible and verifiable** through material execution. When a developer submits a pull request, they are not merely stating a claim but offering an executable artifact for verification. The “understanding” is not a matter of subjective interpretation but of whether the code compiles, passes tests, and fits the system’s existing architecture. This lends hacking a materially grounded form of **closure**, distinct from deliberative or symbolic validation.

Moreover, communication within hacking communities does not only occur through speech or text—it is embedded in commits, diffs, version control logs, and automated test results. These mediums **carry and constrain meaning**, making certain forms of communication possible while rendering others invisible. The infrastructure itself becomes a participant in the communicative loop, enforcing the system’s distinction: working / not working.

### **2.2 From Symbolic to Executable Codes**

If Luhmann’s functional systems are characterized by **symbolically generalized codes**, we propose that hacking operates through what might be called an **executably enforced code**. The distinction between working / not working is not arbitrated by semantics or institutional norms but is **materially instantiated** in executable behavior. A patch is accepted not because it aligns with a norm or argument, but because it _works_—a fact testable by compilation, execution, and testing.

This raises a conceptual challenge: can such a materially enforced binary qualify as a **social system code** in the Luhmannian sense? We argue that it can—provided that the distinction becomes recursively linked through communicative reproduction. If developers repeatedly orient their decisions, contributions, and evaluations around the working / not working distinction, and if this distinction is collectively maintained and reinforced through infrastructure, norms, and feedback loops, then we have the elements of an autopoietic system.

Furthermore, just as in other systems, **programmes** evolve to support this code. In hacking, programmes include test suites, style guides, contribution protocols, and continuous integration pipelines. These do not replace the code; they make its application more context-sensitive and scalable. The combination of testable code and flexible programmes allows hacking communities to grow in complexity without sacrificing closure—a key trait of autopoietic systems.

### **2.3 Closure, Recursion, and the Role of Infrastructure**


A defining trait of autopoietic systems is their **operational closure**: communications reference only other communications of the same system. This raises a further question—how does hacking maintain closure when it draws on diverse elements like legal licenses, scientific methods, or economic incentives?

The answer lies in how the system **filters and recodes external irritations**. For example, the GPL license (a legal artifact) does not enter the hacking system in its legal form; it enters as a **constraint on modification and redistribution**—elements that are processed in terms of what can or cannot work within the given codebase. Similarly, economic incentives may motivate contributions, but the system only registers those contributions that function—i.e., that compile, run, and pass review.

This suggests a model of **semi-permeable closure**, in which hacking retains operational autonomy while structurally coupling with other systems. Infrastructure plays a crucial role in this. Tools like GitHub, Docker, and Jenkins serve both as **media of communication** and as **boundary-maintaining devices**. They enable the recursion of hacking communication (through issues, branches, forks, and pull requests) while insulating the system from semantic overload. They filter what counts as a valid contribution based on the working / not working code.

### **2.4 Toward a Practice-Based Systemic Perspective**

Luhmann’s theory of social systems has sometimes been critiqued for its **distance from embodied practice**. However, hacking offers a unique case where **practice and system coincide**: the act of modifying code and the reproduction of the system are one and the same. Each successful build, each merged pull request, is both a local accomplishment and a moment in the reproduction of the system.

This brings Luhmann’s theory into dialogue with **practice-based theories** of organization and knowledge (e.g., Suchman, Orlikowski, Gherardi), but with a crucial difference: hacking does not rely on tacit knowledge or routine repetition alone. Its closure is grounded in the **shared manipulability of artifacts**—a form of collective enactment that is **repeatable, observable, and versionable**.

In this light, hacking emerges as a social system that is **practically closed and materially open**—a paradox that challenges traditional distinctions between technical and social, between code and communication, and between execution and meaning. It demands a rethinking of how systems can be autopoietic not through symbolic abstraction but through concrete enactment.