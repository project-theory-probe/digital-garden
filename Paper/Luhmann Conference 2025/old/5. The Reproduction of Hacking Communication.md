### **5. The Reproduction of Hacking Communication**

  

**Purpose:** Show how the system began to self-reproduce.

**Content:**

- How internal decisions became stabilized: version control, forkability, licensing models.
    
- Role of Free Software Movement, Copyleft, Open Source (without reifying them).
    
- Linux as empirical culmination—not origin or exemplar, but proof of sustained closure.
    
- Material-discursive institutions arise to sustain the code of working / not working.


## **5. The Reproduction of Hacking Communication**

If we take Niklas Luhmann’s proposition seriously—that social systems reproduce themselves through communication rather than actors—then the hacker system must be understood not as a collective of people who “do hacking,” but as a recursive loop of communicative operations that continuously reproduce the system by observing, selecting, and distinguishing what counts as hacking. This reproduction occurs without a center, without consensus, and without a predefined purpose. It persists as long as communication can continue to reference itself as hacking.

This section clarifies the autopoietic structure of hacking communication. We propose that the hacker system achieves self-reproduction through recursive decision premises, a binary programming code of “working / not working,” and internally stabilized forms of conflict resolution. These mechanisms enable the system to preserve closure while remaining open to environmental irritations (e.g. law, capital, institutions), which it processes through internal codes rather than dissolving into them.

### **5.1 Communication Systems and Closure**

Following Luhmann, a communication system is operationally closed: it can only process information through its own communicative operations. It cannot “receive” input from the environment directly but must translate any external irritation into distinctions that make sense within its own logic. For hacking, this logic is grounded in code and execution—its foundational code is the distinction between “working” and “not working.”

This code governs more than just technical performance; it functions as a _semantic constraint_ on what counts as valid communication. A pull request, a patch, or a bug report is not accepted because it reflects objective truth or personal authority, but because it resolves a condition of “not working” and re-establishes “working” as judged by the system’s expectations. Even aesthetics or refactoring decisions are framed by this underlying code: does this improve reproducibility, readability, or long-term functioning?

Operational closure ensures that the hacker system does not become a vessel for external imperatives. While it may interface with other systems (e.g. legal, economic), its continued identity depends on preserving this binary coding and recursive logic of decision.

### **5.2 Decision Premises and Structural Reproduction**

Hacking reproduces itself not through one-time choices, but through _decision premises_—second-order structures that guide future decisions. These include conventions, toolchains, modular architectures, community norms, and established workflows. They do not decide outcomes but delimit the space of acceptable operations.

For example, a repository may enforce contribution guidelines, a CI/CD pipeline, or module boundaries. These function like Luhmann’s decision programs in organizations: they reduce complexity by narrowing communicative possibilities. A contributor may not know the entire system, but they can act meaningfully within its defined premises.

This structure is recursive: new contributions build upon inherited patterns, and each accepted contribution alters the conditions for future contributions. This is how the system evolves without needing a master plan. The reproduction of hacking communication is therefore not about consensus or command, but about maintaining a living archive of communicative patterns—each one referencing and reentering the history of prior operations.

This recursion also has a temporal dimension. Contributions gain legitimacy not only from the present but from their position in the history of systemic reproduction. A library that “works” and has “worked” becomes part of the de facto infrastructure, even if no one actively curates it. The system’s memory is embedded in tools, idioms, and linkages.

### **5.3 Programming the System: Working / Not Working**

The internal code of “working / not working” acts as a programming logic that filters what communications are continued, which are ignored, and which are revised. This binary may appear narrow, but its application is rich and multi-layered.

First, “working” is not an ontological property—it is a system-specific judgment. A library may be technically functional but “not working” in terms of version compatibility, test coverage, or security vulnerabilities. Conversely, a hacky workaround may be “working” because it fulfills a role in the dependency graph.

Second, this code functions recursively. When a contributor suggests a change, the system tests whether it still “works”—via automated tools, peer review, or downstream usage. If it fails, the operation is rejected. If accepted, it becomes part of the system’s memory and influences the next evaluation cycle. This is not democratic or deliberative in a conventional sense. It is a non-human, cybernetic logic of iterative filtering.

Third, “working / not working” operates across multiple levels: individual commits, modules, dependencies, and even social dynamics (e.g. a maintainer “not working” in terms of responsiveness may trigger a fork). This elasticity allows the system to evolve while remaining internally coded.

### **5.4 Conflict Without Breakdown**

One of the most remarkable features of hacking as a system is its ability to handle conflict without organizational breakdown. Disagreements do not require consensus but are processed through forking, divergence, or parallel development. This is enabled by the system’s structural affordance: the communicative reproduction is not halted by difference—it is fed by it.

Conflict resolution in hacking does not follow juridical or hierarchical models. Instead, it follows communicative reproduction. If a fork gains adoption, it continues as a valid subsystem. If it does not, it is pruned by lack of reference. This means that legitimacy is not conferred by external validation but by systemic uptake.

This dynamic stabilizes conflict through reproduction: difference leads to differentiation, not collapse. One can reject a decision and still remain within the system—by producing alternative communication. This is not a sign of weakness but a core mechanism of reproductive diversity.

Moreover, conflict becomes a way to evolve decision premises. A long-standing disagreement may trigger refactoring, new tool adoption, or modular restructuring. These changes, once operationalized, alter the premises of future decisions. Thus, conflict is a productive force within systemic autopoiesis, not a failure mode.

### **5.5 Autonomy Without Identity**

Because the hacker system is organized around communication, not actors or roles, identity is always secondary. Contributors may come and go, use pseudonyms, or reappear under different names. What matters is whether their contributions are reproduced in the system. Autonomy in this system does not depend on selfhood but on communicative uptake.

This shifts the question of “who counts” from a sociological to a systemic register. A person may be influential not because of their name, but because of the recurrence of their style, ideas, or tools. Influence is measured not by recognition, but by structural embedding.

This decentering of identity is also what allows the hacker system to remain resilient. It is not bound to charismatic leaders or institutional frameworks. It can survive attrition, departure, and even controversy—because reproduction is embedded in communication, not individuals.

At the same time, the system constructs its own internal identities: maintainers, contributors, users. These are not legal or formal roles but communicatively stabilized distinctions. They guide expectation structures but can always be reentered, redefined, or forked away from.

### **5.6 Self-Description and Reflexivity**

As with all social systems, hacking develops its own self-descriptions. These take the form of manifestos, style guides, README files, mailing list etiquette, or design philosophies. These texts do not determine the system but reflect and influence its evolution.

Self-description enables second-order observation: the system observes how it observes itself. This reflexivity allows for shifts in norms, values, and priorities—without abandoning the code of “working / not working.” For example, concerns about accessibility or sustainability may lead to new metrics for what counts as “working.”

However, self-description is always selective. It cannot capture the totality of systemic operations. It simplifies and guides attention. Still, its presence is vital: it enables communication about communication, and thus allows the hacker system to manage its own transformation.