### Abstract

This paper examines a set of operations in software development that reproduces itself via a binary distinction (working / not working). While “software” often refers to technical artifacts, this paper focuses on the communicative operations surrounding software creation, evaluation, and distribution—operations that have become increasingly self-referential and recursively reproduced. It explores how a set of communicative practices—initially grounded in pragmatic problem-solving—implicitly enacted the distinction working / not working, which only later became stabilized as a binary code guiding communication, distinct from adjacent systems such as law, science, or economy.

While the standard Luhmannian view treats the code as structurally prior to the programme—with the latter serving to conditionally apply the former—this paper instead argues that code and programme co-emerged through recursive, materially embedded practices. In the context of early software communities—particularly among engineers and students in university settings in the 1970s and 1980s—the distinction working / not working was not explicitly articulated, but was implicitly enacted in communicative decisions about functionality, contribution, and reuse.

The shift was not driven by ideals of openness, but by communicative responses to persistent irritations from legal and commercial systems, which restricted access, modification, and distribution of software. Over time, these recursive responses took shape as programmes—such as contribution guidelines, version control practices, and testing conventions—that made the implicit code practically applicable and increasingly stable. As these operations became more self-referential, software communication moved toward operational closure, producing and evaluating its own contributions through system-internal criteria.

The paper highlights three notable sites of communication in this process. First, in the informal engineering communities surrounding university computers and early UNIX systems, we observe communicative practices centered on whether code functioned in practice—irrespective of legality, profitability, or authorship. Second, the GNU Project attempted to formalize the ethos of shared source code through legal instruments and normative claims, but struggled to establish the programmes necessary for recursive reproduction and system-level scaling. Third, in the development practices around the Linux kernel, we see the crystallization of decision-making procedures (e.g., maintainership hierarchies, Git-based commits, automated testing) that allowed the system to reproduce its operations based on internal criteria—anchored in the distinction of working / not working.

This argument does not locate system genesis in specific individuals or causal events. Rather, it shows how contingent configurations of practice and irritation produced conditions under which communications became increasingly self-referential—selected and continued based on prior operations. Communication is mediated by source code that is executable, enabling a distinction that is not merely symbolic but materially enforced: it either works or it does not. Reproducibility here is not just a condition for testing but a basis for shared reference: contributors encounter, modify, and evaluate the same material instantiations, allowing collaboration to proceed through enacted proposals rather than semantic consensus. It proposes that software development communicates in a way that no longer depends on the legal code (legal/illegal), economic code (payment/non-payment), or scientific code (true/false) for its communicative reproduction, even as it remains structurally coupled to all three.

The paper contributes to the theory of functionally differentiated communication systems by extending the discussion of code and programme beyond established systems. First, it demonstrates how a code—though implicit—can become socially effective through the contingent evolution of programmes that actualize and reinforce its operations. Second, it emphasizes that functional differentiation can occur outside institutional foundations, through practices that gradually gain autonomy and closure. Third, it foregrounds how materially reproducible artefacts—such as source code—can function as communicative media, enabling selectivity and recursion not through symbolic generalization but through executable instantiation. Rather than tracing a single origin, the analysis focuses on how software development reproduces its own boundaries, organizes its own communications, and selectively integrates irritations from other systems.
